import React, { useState, useMemo } from 'react';
import { Info } from 'lucide-react';

const InfoBox = ({ what, why }) => {
  const [open, setOpen] = useState(false);
  return (
    <div className="relative inline-block">
      <button
        type="button"
        onClick={() => setOpen(!open)}
        className="ml-2 text-gray-400 hover:text-gray-600 focus:outline-none"
      >
        <Info className="w-4 h-4" />
      </button>
      {open && (
        <div className="absolute z-10 w-72 p-3 text-xs bg-gray-900 text-white rounded-lg shadow-lg">
          <p className="font-semibold mb-1">What it means</p>
          <p className="mb-2 whitespace-pre-line">{what}</p>
          <p className="font-semibold mb-1">Why it matters</p>
          <p className="whitespace-pre-line">{why}</p>
        </div>
      )}
    </div>
  );
};

export default function ElasticSearchRamCalculator() {
  const [docSize, setDocSize] = useState(2000);
  const [chunkSize, setChunkSize] = useState(1000);
  const [numDocs, setNumDocs] = useState(1000);
  const [embeddingDim, setEmbeddingDim] = useState(512);
  const [numericType, setNumericType] = useState('float32');
  const [includeMetadata, setIncludeMetadata] = useState(true);
  const [metadataSize, setMetadataSize] = useState(2500);
  const [includeIndex, setIncludeIndex] = useState(true);
  const [indexOverhead, setIndexOverhead] = useState(15);

  const calculations = useMemo(() => {
    const bytesPerValue = numericType === 'float32' ? 4 : 2;
    const chunksPerDoc = docSize > 0 && chunkSize > 0 ? Math.ceil(docSize / chunkSize) : 0;
    const totalVectors = numDocs * chunksPerDoc;
    const bytesPerVector = embeddingDim * bytesPerValue;
    const vectorBytes = totalVectors * bytesPerVector;
    const metadataBytes = includeMetadata ? metadataSize * totalVectors : 0;
    const totalBeforeIndex = vectorBytes + metadataBytes;
    const indexBytes = includeIndex ? totalBeforeIndex * (indexOverhead / 100) : 0;
    const totalBytes = totalBeforeIndex + indexBytes;
    return {
      bytesPerValue,
      chunksPerDoc,
      totalVectors,
      vectorBytes,
      metadataBytes,
      indexBytes,
      totalBytes,
    };
  }, [docSize, chunkSize, numDocs, embeddingDim, numericType, includeMetadata, metadataSize, includeIndex, indexOverhead]);

  const formatMB = (bytes) => (bytes / (1024 ** 2)).toLocaleString(undefined, { maximumFractionDigits: 2 });
  const formatGB = (bytes) => (bytes / (1024 ** 3)).toLocaleString(undefined, { maximumFractionDigits: 2 });

  return (
    <div className="space-y-8">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div>
          <label className="flex items-center font-medium text-gray-700">
            Avg document length (chars)
            <InfoBox
              what="Average length of each source document before chunking."
              why="Combined with chunk size, determines how many chunks each document becomes."
            />
          </label>
          <input
            type="number"
            className="mt-1 w-full border rounded-lg px-3 py-2"
            value={docSize}
            onChange={(e) => setDocSize(parseInt(e.target.value) || 0)}
          />
        </div>

        <div>
          <label className="flex items-center font-medium text-gray-700">
            Chunk size (characters)
            <InfoBox
              what="How you split documents into smaller text units before embedding."
              why="Affects the number of vectors you store. Smaller chunks = more vectors per document = higher storage and indexing cost, but potentially better retrieval accuracy."
            />
          </label>
          <input
            type="number"
            className="mt-1 w-full border rounded-lg px-3 py-2"
            value={chunkSize}
            onChange={(e) => setChunkSize(parseInt(e.target.value) || 0)}
          />
        </div>

        <div>
          <label className="flex items-center font-medium text-gray-700">
            Number of documents
            <InfoBox
              what="The total count of source documents in your system."
              why="Combined with chunk size, it drives the total number of vectors you’ll generate and store."
            />
          </label>
          <input
            type="number"
            className="mt-1 w-full border rounded-lg px-3 py-2"
            value={numDocs}
            onChange={(e) => setNumDocs(parseInt(e.target.value) || 0)}
          />
        </div>

        <div>
          <label className="flex items-center font-medium text-gray-700">
            Embedding dimension
            <InfoBox
              what="Length of the vector generated by your embedding model (OpenAI, HuggingFace, etc.)."
              why="Storage cost grows linearly with dimension size. Example: 512-dim float32 = 2 KB per vector, while 1536-dim = 6 KB per vector."
            />
          </label>
          <input
            type="number"
            className="mt-1 w-full border rounded-lg px-3 py-2"
            value={embeddingDim}
            onChange={(e) => setEmbeddingDim(parseInt(e.target.value) || 0)}
          />
        </div>

        <div>
          <label className="flex items-center font-medium text-gray-700">
            Numeric type
            <InfoBox
              what={"How each dimension number is stored:\n\nfloat32: 4 bytes per value (most common in Elasticsearch today).\n\nfloat16: 2 bytes (if your pipeline supports half-precision)."}
              why={"Directly halves (or doubles) storage per vector.\nElasticsearch dense_vector field typically uses float32 internally."}
            />
          </label>
          <select
            className="mt-1 w-full border rounded-lg px-3 py-2"
            value={numericType}
            onChange={(e) => setNumericType(e.target.value)}
          >
            <option value="float32">float32</option>
            <option value="float16">float16</option>
          </select>
        </div>

        <div className="md:col-span-2">
          <label className="flex items-center font-medium text-gray-700">
            <input
              type="checkbox"
              className="mr-2"
              checked={includeMetadata}
              onChange={(e) => setIncludeMetadata(e.target.checked)}
            />
            Metadata size per vector (bytes)
            <InfoBox
              what={"Extra JSON fields stored alongside each vector in Elasticsearch:\n\nDocument ID, chunk text, tags, timestamps, etc."}
              why={"Often bigger than the vector itself. For example:\n\nVector (512 × float32) ≈ 2 KB\n\nMetadata (chunk text of ~2000 chars + IDs) ≈ 2–3 KB\nThis dominates storage in Elasticsearch since it’s a JSON document store."}
            />
          </label>
          {includeMetadata && (
            <input
              type="number"
              className="mt-1 w-full border rounded-lg px-3 py-2"
              value={metadataSize}
              onChange={(e) => setMetadataSize(parseInt(e.target.value) || 0)}
            />
          )}
        </div>

        <div className="md:col-span-2">
          <label className="flex items-center font-medium text-gray-700">
            <input
              type="checkbox"
              className="mr-2"
              checked={includeIndex}
              onChange={(e) => setIncludeIndex(e.target.checked)}
            />
            Index overhead (%)
            <InfoBox
              what={"Extra bytes Elasticsearch adds for indexing and search structures:\n\nInverted index, doc values, Lucene overhead.\n\nFor dense_vector fields, Elasticsearch doesn’t index every dimension, but if you enable knn_vector search with HNSW, there’s graph overhead."}
              why={"Adds 10–30% more storage, depending on configuration. It’s why a “raw size” calculation underestimates Elasticsearch’s real disk usage."}
            />
          </label>
          {includeIndex && (
            <input
              type="number"
              className="mt-1 w-full border rounded-lg px-3 py-2"
              value={indexOverhead}
              onChange={(e) => setIndexOverhead(parseFloat(e.target.value) || 0)}
            />
          )}
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        <div className="p-4 bg-gray-50 rounded-lg">
          <div className="text-sm text-gray-600">Chunks per document</div>
          <div className="text-lg font-semibold">{calculations.chunksPerDoc.toLocaleString()}</div>
        </div>
        <div className="p-4 bg-gray-50 rounded-lg">
          <div className="text-sm text-gray-600">Total vectors</div>
          <div className="text-lg font-semibold">{calculations.totalVectors.toLocaleString()}</div>
        </div>
        <div className="p-4 bg-gray-50 rounded-lg">
          <div className="text-sm text-gray-600">Vector storage</div>
          <div className="text-lg font-semibold">{formatMB(calculations.vectorBytes)} MB</div>
        </div>
        {includeMetadata && (
          <div className="p-4 bg-gray-50 rounded-lg">
            <div className="text-sm text-gray-600">Metadata storage</div>
            <div className="text-lg font-semibold">{formatMB(calculations.metadataBytes)} MB</div>
          </div>
        )}
        {includeIndex && (
          <div className="p-4 bg-gray-50 rounded-lg">
            <div className="text-sm text-gray-600">Index overhead</div>
            <div className="text-lg font-semibold">{formatMB(calculations.indexBytes)} MB</div>
          </div>
        )}
        <div className="p-4 bg-gray-100 rounded-lg md:col-span-2 lg:col-span-3">
          <div className="text-sm text-gray-600">Total storage</div>
          <div className="text-xl font-bold">
            {calculations.totalBytes.toLocaleString()} bytes ({formatMB(calculations.totalBytes)} MB / {formatGB(calculations.totalBytes)} GB)
          </div>
        </div>
      </div>

      <div className="text-sm text-gray-600">
        <p className="font-semibold mb-1">Why all this matters in Elasticsearch</p>
        <p>
          Unlike specialized vector DBs, Elasticsearch stores each chunk as a full JSON document containing both the dense_vector field and metadata.
          The vector dim × numeric type tells you the raw space. The metadata size reflects your schema (text + IDs). The index overhead reflects Lucene’s structures.
          That’s why you need all of them: without metadata and index overhead, you’d severely underestimate Elasticsearch disk usage.
        </p>
      </div>
    </div>
  );
}

